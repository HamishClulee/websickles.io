(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0e5ee5"],{"971b":function(e,t){e.exports='<h1 style="text-align:center;">Vue.js</h1>\n\n<p style="text-align:center;">A Javascript framework for building Single Page Apps (SPAs).</p>\n\n<h1 id="table-of-contents">Table of Contents</h1>\n<ul>\n<li><a href="#vuejs">Vue.js</a></li>\n<li><a href="#basics">Basics</a><ul>\n<li><a href="#data-property">Data Property</a></li>\n<li><a href="#methods">Methods</a></li>\n<li><a href="#vue-instance-lifecycle">Vue Instance Lifecycle</a></li>\n<li><a href="#computed-property">Computed Property</a></li>\n<li><a href="#watch-property">Watch Property</a></li>\n<li><a href="#directives">Directives</a><pre><code>* [Shortcuts](#shortcuts)</code></pre></li>\n<li><a href="#dynamic-styles">Dynamic Styles</a><ul>\n<li><a href="#array-sytax">Array Sytax</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href="#vue-cli--workflows">Vue CLI &amp; Workflows</a><ul>\n<li><a href="#development-workflow">Development Workflow</a></li>\n<li><a href="#components">Components</a><ul>\n<li><a href="#registering-components-locally">Registering Components Locally</a></li>\n</ul>\n</li>\n<li><a href="#communicating-between-components">Communicating between Components</a><ul>\n<li><a href="#parent---child">Parent -&gt; <strong>Child</strong></a></li>\n<li><a href="#child---parent">Child -&gt; Parent</a></li>\n<li><a href="#child---child">Child -&gt; Child</a><ul>\n<li><a href="#method-1">Method #1</a></li>\n<li><a href="#method-2">Method #2</a></li>\n<li><a href="#method-3">Method #3</a></li>\n<li><a href="#event-bus">Event Bus</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href="#advanced-components">Advanced Components</a><ul>\n<li><a href="#slots">Slots</a><ul>\n<li><a href="#multiple-slots">Multiple Slots</a></li>\n</ul>\n</li>\n<li><a href="#dynamic-components">Dynamic Components</a></li>\n</ul>\n</li>\n<li><a href="#custom-directives">Custom Directives</a><ul>\n<li><a href="#passing-values-to-custom-directives">Passing values to custom directives</a><ul>\n<li><a href="#arguments">Arguments</a></li>\n<li><a href="#modifiers">Modifiers</a></li>\n</ul>\n</li>\n<li><a href="#registering-directives-locally">Registering Directives locally</a></li>\n</ul>\n</li>\n<li><a href="#filters">Filters</a></li>\n<li><a href="#mixins">Mixins</a></li>\n</ul>\n</li>\n<li><a href="#animations">Animations</a><ul>\n<li><a href="#transition">Transition</a><ul>\n<li><a href="#assigning-css-classes-for-transitions">Assigning CSS classes for Transitions</a></li>\n</ul>\n</li>\n<li><a href="#animation">Animation</a><pre><code>* [Onload animation](#onload-animation)</code></pre></li>\n<li><a href="#custom-css-classes-names">Custom CSS Classes Names</a></li>\n<li><a href="#transitioning-between-multiple-elements">Transitioning between Multiple Elements</a></li>\n<li><a href="#transition-js-hooks">Transition JS Hooks</a></li>\n<li><a href="#multiple-elements-animations">Multiple Elements Animations</a></li>\n</ul>\n</li>\n<li><a href="#vue-router">Vue Router</a><ul>\n<li><a href="#route-parameters">Route Parameters</a><ul>\n<li><a href="#query-parameters">Query parameters</a></li>\n</ul>\n</li>\n<li><a href="#nested-routes">Nested Routes</a></li>\n<li><a href="#scroll-behavior">Scroll behavior</a></li>\n<li><a href="#navigation-guards">Navigation Guards</a></li>\n<li><a href="#lazy-loading">Lazy Loading</a></li>\n</ul>\n</li>\n<li><a href="#vuex---better-state-management">Vuex - Better State Management</a><ul>\n<li><a href="#install">Install</a></li>\n<li><a href="#store">Store</a></li>\n<li><a href="#getters">Getters</a><ul>\n<li><a href="#mapping-getters-to-properties">Mapping Getters to Properties</a></li>\n</ul>\n</li>\n<li><a href="#mutations">Mutations</a></li>\n<li><a href="#actions">Actions</a><pre><code>* [Edge with v-model](#edge-with-v-model)</code></pre></li>\n<li><a href="#modularizing-the-store">Modularizing the Store</a></li>\n</ul>\n</li>\n</ul>\n<h1 id="basics">Basics</h1>\n<p>A simple Vue.js built in the browser looks like this.</p>\n<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;\n  {{ message }}\n&lt;/div&gt;\n\n&lt;script&gt;\n    const app = new Vue({\n        el: &#39;#app&#39;,\n        data: {\n            message: &#39;Hello Vue!&#39;\n        }\n    });\n&lt;/script&gt;</code></pre>\n<p>We bind the application to a root element, in this case a DIV. Every Vue application starts by creating a new <strong>Vue instance</strong> with the <code>Vue</code> function.</p>\n<p>A Vue application consists of a <strong>root Vue instance</strong> created with <code>new Vue</code>, optionally organized into a tree of nested, reusable components. For  example, a todo app’s component tree might look like this:</p>\n<pre><code>Root Instance\n└─ TodoList\n   ├─ TodoItem\n   │  ├─ DeleteTodoButton\n   │  └─ EditTodoButton\n   └─ TodoListFooter\n      ├─ ClearTodosButton\n      └─ TodoListStatistics</code></pre><h3 id="data-property">Data Property</h3>\n<p>When a Vue instance is created, it adds all the properties found in its <code>data</code> object to Vue’s <strong>reactivity system</strong>. When the values of those properties change, the view will “react”, updating to match the new values.</p>\n<p>We use the <code>{{ }}</code> syntax to display dynamic values taken from the <code>data</code> property (see <a href="#Basics">Basics</a>). We can also put small JS syntax inside <code>{{ }}</code>.</p>\n<pre><code class="language-javascript">const vm = new Vue({\n    el: &#39;#app&#39;,\n\n    data: {\n        num = 100;\n    }\n});</code></pre>\n<p>When this data changes, the view will re-render.</p>\n<p><strong>The data property is not reactive.</strong></p>\n<h3 id="methods">Methods</h3>\n<p>Methods can also be accessed in the view with the <code>{{ }}</code> syntax:</p>\n<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;\n  {{ sayHello() }}\n&lt;/div&gt;\n\n&lt;script&gt;\n    const app = new Vue({\n        el: &#39;#app&#39;,\n        data: {\n            message: &#39;Hello Vue!&#39;\n        }\n        methods: {\n            sayHello() {\n                return &#39;Hello!&#39;;\n            }\n        }\n    });\n&lt;/script&gt;</code></pre>\n<p>The <code>{{ }}</code> syntax can&#39;t be used in every element attribute:</p>\n<pre><code class="language-html">&lt;!-- NO --&gt;\n&lt;a href=&quot;{{ link }}&quot;&gt;Link&lt;/a&gt;</code></pre>\n<p>We need to use <a href="#Directives"><strong>Directives</strong></a>.</p>\n<pre><code class="language-html">&lt;a v-bind:href=&quot;link&quot;&gt;Link&lt;/a&gt;</code></pre>\n<h3 id="vue-instance-lifecycle">Vue Instance Lifecycle</h3>\n<p><img src="https://vuejs.org/images/lifecycle.png" alt="The Vue Instance Lifecycle"></p>\n<p>We have access to different methods for different periods in the lifecycle of an instance. For example we can use the <code>created()</code> method and run code once the Vue instance gets created.</p>\n<p>See documentation for more methods.</p>\n<h3 id="computed-property">Computed Property</h3>\n<p>With the computed property we can execute a function only if its relative data gets changed. The methods are called every time we dynamically refresh the page. For example let&#39;s assume we have some buttons that increase a counter:</p>\n<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;\n    &lt;button v-on:click=&quot;counter++&quot;&gt;Increase&lt;/button&gt;\n    &lt;button v-on:click=&quot;counter--&quot;&gt;Decrease&lt;/button&gt;\n    &lt;button v-on:click=&quot;secodCounter++&quot;&gt;Increase second&lt;/button&gt;\n\n    &lt;p&gt;Counter: {{ counter }}&lt;/p&gt;\n    &lt;p&gt;Result: {{ result() }} | {{ output }}&lt;/p&gt;\n&lt;/div&gt;\n\n&lt;script&gt;\n    new Vue({\n        el: &#39;#app&#39;,\n        data: {\n            counter: 0,\n            seconCounter: 0\n        },\n        computed: {\n            output() {\n                return this.counter &gt; 5 ? &#39;Greater than 5&#39; : &#39;Smaller than 5&#39;\n            }\n        },\n        methods: {\n            result() {\n                return this.counter &gt; 5 ? &#39;Greater than 5&#39; : &#39;Smaller than 5&#39;\n            }\n        }\n    });\n&lt;/script&gt;</code></pre>\n<p>The result function gets called every time because Vue doesn&#39;t know if it needs to run it or not. On the other hand the output function gets called only when the counter gets modified.</p>\n<p>Computed is aware of the logic inside it. See how we use &#39;output&#39; as a property and we don&#39;t invoke the function.</p>\n<p>Computed properties are by default getter-only, but you can also provide a setter when you need it:</p>\n<h3 id="watch-property">Watch Property</h3>\n<p>An object where keys are expressions to watch and values are the  corresponding callbacks. The value can also be a string of a method  name, or an Object that contains additional options. </p>\n<p>Vue does provide a more generic way to observe and react to data changes on a Vue instance: <strong>watch properties</strong>. When you have some data that needs to change based on some other data, it is tempting to overuse <code>watch</code> owever, it is often a better idea to use a computed property rather than an imperative <code>watch</code> callback</p>\n<p>The watch property lets us react to changes. Computed properties are much more optimized and they are best practice but they need to run <strong>SYNC</strong>.</p>\n<p>The watch property is <strong>ASYNC</strong>.</p>\n<h3 id="directives">Directives</h3>\n<p>Directives are special Vue commands.</p>\n<table>\n<thead>\n<tr>\n<th align="center">keyword</th>\n<th align="center">action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align="center">v-bind</td>\n<td align="center">bind some data dynamically to something</td>\n</tr>\n<tr>\n<td align="center">v-if</td>\n<td align="center">if statement</td>\n</tr>\n<tr>\n<td align="center">v-else</td>\n<td align="center">else statement</td>\n</tr>\n<tr>\n<td align="center">v-for</td>\n<td align="center">for loop</td>\n</tr>\n<tr>\n<td align="center">v-once</td>\n<td align="center">freezes dynamic updating (hot reload)</td>\n</tr>\n<tr>\n<td align="center">v-html</td>\n<td align="center">outputs raw html data from a value ([!] XSS [!])</td>\n</tr>\n<tr>\n<td align="center">v-on</td>\n<td align="center">listens on an event (click...)</td>\n</tr>\n<tr>\n<td align="center">v-model</td>\n<td align="center">Create a two-way binding on a form input element or a component.</td>\n</tr>\n</tbody></table>\n<h4 id="shortcuts">Shortcuts</h4>\n<p><code>v-on: --&gt; @</code></p>\n<p><code>v-bind: --&gt; :</code></p>\n<h3 id="dynamic-styles">Dynamic Styles</h3>\n<p>We can pass an object to <code>v-bind:class</code> to dynamically toggle classes:</p>\n<pre><code class="language-html">&lt;div v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt;</code></pre>\n<p>The above syntax means the presence of the <code>active</code> class will be determined by the <a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">truthiness</a> of the data property <code>isActive</code>.</p>\n<p>You can have multiple classes toggled by having more fields in the object. In addition, the <code>v-bind:class</code> directive can also co-exist with the plain <code>class</code> attribute. So given the following template:</p>\n<pre><code class="language-html">&lt;div\n  class=&quot;static&quot;\n  v-bind:class=&quot;{ active: isActive, &#39;text-danger&#39;: hasError }&quot;\n&gt;&lt;/div&gt;</code></pre>\n<p>And the following data:</p>\n<pre><code class="language-javascript">data: {\n  isActive: true,\n  hasError: false\n}</code></pre>\n<p>It will render:</p>\n<pre><code class="language-html">&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;</code></pre>\n<p>The bound object doesn’t have to be inline:</p>\n<pre><code class="language-html">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</code></pre>\n<pre><code class="language-javascript">data: {\n  classObject: {\n    active: true,\n    &#39;text-danger&#39;: false\n  }\n}</code></pre>\n<p>This will render the same result. We can also bind to a <a href="https://vuejs.org/v2/guide/computed.html">computed property</a> that returns an object. This is a common and powerful pattern:</p>\n<pre><code class="language-html">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</code></pre>\n<pre><code class="language-javascript">data: {\n  isActive: true,\n  error: null\n},\ncomputed: {\n  classObject: function () {\n    return {\n      active: this.isActive &amp;&amp; !this.error,\n      &#39;text-danger&#39;: this.error &amp;&amp; this.error.type === &#39;fatal&#39;\n    }\n  }\n}</code></pre>\n<h4 id="array-sytax">Array Sytax</h4>\n<p>We can pass an array to <code>v-bind:class</code> to apply a list of classes:</p>\n<pre><code class="language-html">&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;</code></pre>\n<pre><code class="language-javascript">data: {\n  activeClass: &#39;active&#39;,\n  errorClass: &#39;text-danger&#39;\n}</code></pre>\n<p>Which will render:</p>\n<pre><code class="language-html">&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;</code></pre>\n<p>If you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:</p>\n<pre><code class="language-html">&lt;div v-bind:class=&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;/div&gt;</code></pre>\n<p>This will always apply <code>errorClass</code>, but will only apply <code>activeClass</code> when <code>isActive</code> is truthy.</p>\n<h1 id="vue-cli--workflows">Vue CLI &amp; Workflows</h1>\n<p>Workflows optimize our code in multiple ways. We need, though, a development server:</p>\n<p>This server will pre-compile and then serve the Vue app to the client, this is good for clientside performance.</p>\n<p>All of this is pre-built, we don&#39;t need to write our own static server. </p>\n<h3 id="development-workflow">Development Workflow</h3>\n<p>We compile everything server so the app we ship is ready to be viewed. This means that we can use Single FIled Templates (.vue files).</p>\n<h3 id="components">Components</h3>\n<p>Re-usable pieces of code that are used in the Vue instance. It&#39;s like splitting the app in different parts based on their role. Components extend the Vue instance. </p>\n<p><strong>The data property in components must be a function</strong></p>\n<pre><code class="language-javascript">Vue.component(&#39;ComponentName&#39;, {\n    data() {\n        return {\n            str: &#39;Hello from component&#39;\n        };\n    }\n});\n\nnew Vue({\n    el: &#39;#app&#39;,\n    data: {\n        str: &#39;Hello&#39;\n    }\n});</code></pre>\n<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;\n    &lt;ComponentName /&gt;\n    &lt;ComponentName /&gt;\n    &lt;ComponentName /&gt;\n&lt;/div&gt;\n\n&lt;!-- as you can see we can re-use components --&gt;</code></pre>\n<p>We could also have a shared data object by defining it globally but it is better to have it locally inside every component.</p>\n<h4 id="registering-components-locally">Registering Components Locally</h4>\n<pre><code class="language-javascript">// global\nVue.component(&#39;ComponentName&#39;, {\n    data() {\n        return {\n            str: &#39;Hello from global component&#39;\n        };\n    }\n});</code></pre>\n<pre><code class="language-javascript">// local\nconst ComponentName = {\n    data() {\n        return {\n            str: &#39;Hello from local&#39;\n        }\n    }\n}\n\nconst vm = new Vue({\n       components: {\n        ComponentName\n    } \n});</code></pre>\n<p>We can of course move components to a separated file and import it like a JS module.</p>\n<pre><code class="language-html">&lt;template&gt;\n    &lt;p&gt;\n        {{ str }}\n    &lt;/p&gt;\n    &lt;ComponentName /&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    import ComponentName from &#39;./components/ComponentName.vue&#39;;\n\n    export default {\n        components: {\n            ComponentName\n        },\n\n        data: {\n            str: &#39;Hello&#39;\n        }\n    }\n&lt;/script&gt;</code></pre>\n<p>We can also organize components by feature instead of having a single <code>components</code> folder.</p>\n<h3 id="communicating-between-components">Communicating between Components</h3>\n<h4 id="parent---child">Parent -&gt; <strong>Child</strong></h4>\n<p>How can we share data from parent to child?</p>\n<p>For transferring data from the parent to the child we use <code>props</code>.</p>\n<pre><code class="language-html">&lt;!-- child --&gt;\n&lt;template&gt;\n    &lt;p&gt;\n        {{ name }}\n    &lt;/p&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    export default {\n        props: [&#39;name&#39;]\n    }\n&lt;/script&gt;</code></pre>\n<pre><code class="language-html">&lt;!-- parent --&gt;\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;ChildComponent v-bind:name=&quot;name&quot; /&gt;    &lt;!-- we need v-bind --&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    export default {\n        data() {\n            return {\n                name: &#39;Leonardo&#39;    \n            }\n        }\n    }\n&lt;/script&gt;</code></pre>\n<p>We can also use the props inside methods using the keyword <code>this</code>, just like accessing the data property</p>\n<p>Props can also be an object, it is useful if you want to do some validation.</p>\n<pre><code class="language-javascript">export default {\n    props : {\n         name: String,\n        required: true\n    }\n}</code></pre>\n<h4 id="child---parent">Child -&gt; Parent</h4>\n<p>How can we share data from a child to his parent?</p>\n<p>Since passing data from parent to child means passing pointers we use the <code>$emit</code> method.</p>\n<pre><code class="language-javascript">export default {\n    resetName() {\n        this.name = &#39;Reverted back&#39;;\n        this.$emit(&#39;eventName&#39;, this.name);\n    }\n}</code></pre>\n<p>And then in the parent we listen to this event with the v-on directive.</p>\n<p><code>v-on:eventName=&quot;name = $event&quot;</code> ($event refers to the data passed to the event).</p>\n<h4 id="child---child">Child -&gt; Child</h4>\n<ul>\n<li><h4 id="method-1">Method #1</h4>\n<p>​    Emetting event like we did [here](####Child -&gt; Parent).</p>\n</li>\n<li><h4 id="method-2">Method #2</h4>\n<p>​    Passing a callback as a prop</p>\n</li>\n<li><h4 id="method-3">Method #3</h4>\n<p>​    Using an Event Bus, which is a separeted Vue instance. We use <code>$emit</code> with this instance     and we listen from events coming from that Bus.</p>\n</li>\n</ul>\n<h4 id="event-bus">Event Bus</h4>\n<pre><code class="language-javascript">// main.js\nimport Vue from &#39;vue&#39;\nimport App from &#39;./App.vue&#39;\n\nexport const eventBus = new Vue({\n    methods: {\n        changeAge(age) {\n            this.$emit(&#39;ageWasEdited&#39;, age);\n        }\n    }\n});\n\nnew Vue({\n  el: &#39;#app&#39;,\n  render: h =&gt; h(App)\n})</code></pre>\n<pre><code class="language-html">&lt;!-- child 1 --&gt;\n&lt;template&gt;\n    &lt;div class=&quot;component&quot;&gt;\n        &lt;h3&gt;You may edit the User here&lt;/h3&gt;\n        &lt;p&gt;Edit me!&lt;/p&gt;\n        &lt;p&gt;User Age: {{ userAge }}&lt;/p&gt;\n        &lt;button @click=&quot;editAge&quot;&gt;Edit Age&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    import {eventBus} from &#39;../main&#39;;\n\n    export default {\n        props: [&#39;userAge&#39;],\n        methods: {\n            editAge() {\n                this.userAge = 30;\n\n                eventBus.changeAge(this.userAge);\n            }\n        }\n    }\n&lt;/script&gt;</code></pre>\n<pre><code class="language-html">&lt;!-- child 2 --&gt;\n&lt;template&gt;\n    &lt;div class=&quot;component&quot;&gt;\n        &lt;h3&gt;You may view the User Details here&lt;/h3&gt;\n        &lt;p&gt;Many Details&lt;/p&gt;\n        &lt;p&gt;User Name: {{ switchName() }}&lt;/p&gt;\n        &lt;p&gt;User Age: {{ userAge }}&lt;/p&gt;\n        &lt;button @click=&quot;resetName&quot;&gt;Reset Name&lt;/button&gt;\n        &lt;button @click=&quot;resetFn()&quot;&gt;Reset Name&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    import { eventBus } from &#39;../main&#39;;\n\n    export default {\n        props: {\n            myName: {\n                type: String\n            },\n            resetFn: Function,\n            userAge: Number\n        },\n        methods: {\n            switchName() {\n                return this.myName.split(&quot;&quot;).reverse().join(&quot;&quot;);\n            },\n            resetName() {\n                this.myName = &#39;Max&#39;;\n                this.$emit(&#39;nameWasReset&#39;, this.myName);\n            }\n        },\n        created() {\n            eventBus.$on(&#39;ageWasEdited&#39;, (age) =&gt; {\n                this.userAge = age;\n            });\n        }\n    }\n&lt;/script&gt;</code></pre>\n<pre><code class="language-html">&lt;!-- parent --&gt;\n&lt;template&gt;\n    &lt;div class=&quot;component&quot;&gt;\n        &lt;h1&gt;The User Component&lt;/h1&gt;\n        &lt;p&gt;I&#39;m an awesome User!&lt;/p&gt;\n        &lt;button @click=&quot;changeName&quot;&gt;Change my Name&lt;/button&gt;\n        &lt;p&gt;Name is {{ name }}&lt;/p&gt;\n        &lt;p&gt;Age is {{ age }}&lt;/p&gt;\n        &lt;hr&gt;\n        &lt;div class=&quot;row&quot;&gt;\n            &lt;div class=&quot;col-xs-12 col-sm-6&quot;&gt;\n                &lt;app-user-detail\n                        :myName=&quot;name&quot;\n                        @nameWasReset=&quot;name = $event&quot;\n                        :resetFn=&quot;resetName&quot;\n                        :userAge=&quot;age&quot;&gt;&lt;/app-user-detail&gt;\n            &lt;/div&gt;\n            &lt;div class=&quot;col-xs-12 col-sm-6&quot;&gt;\n                &lt;app-user-edit\n                        :userAge=&quot;age&quot;\n                        @ageWasEdited=&quot;age = $event&quot;\n                &gt;&lt;/app-user-edit&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    import UserDetail from &#39;./UserDetail.vue&#39;;\n    import UserEdit from &#39;./UserEdit.vue&#39;;\n\n    export default {\n        data: function () {\n            return {\n                name: &#39;Max&#39;,\n                age: 27\n            };\n        },\n        methods: {\n            changeName() {\n                this.name = &#39;Anna&#39;;\n            },\n            resetName() {\n                this.name = &#39;Max&#39;;\n            }\n        },\n        components: {\n            appUserDetail: UserDetail,\n            appUserEdit: UserEdit\n        }\n    }\n&lt;/script&gt;</code></pre>\n<pre><code class="language-html">&lt;!-- App.vue --&gt;\n&lt;template&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;row&quot;&gt;\n            &lt;div class=&quot;col-xs-12&quot;&gt;\n                &lt;app-user&gt;&lt;/app-user&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    import User from &#39;./components/User.vue&#39;;\n\n    export default {\n        components: {\n            appUser: User\n        }\n    }\n&lt;/script&gt;</code></pre>\n<p>We could also use <strong>Vuex</strong> to simplify State Management.</p>\n<h3 id="advanced-components">Advanced Components</h3>\n<h4 id="slots">Slots</h4>\n<p>With slots we can pass content (entire HTML blocks) between components </p>\n<pre><code class="language-html">&lt;!-- parent --&gt;\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;Quote&gt;\n            &lt;!-- this is going inside the slot component in the child --&gt;\n            &lt;h1&gt;Quote Title&lt;/h1&gt;\n            &lt;p&gt;The quote&lt;/p&gt;\n        &lt;/Quote&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    import Quote from &#39;./components/Quote.vue&#39;;\n\n    export default {\n        components: {\n            Quote\n        }\n    }\n&lt;/script&gt;</code></pre>\n<pre><code class="language-html">&lt;!-- child --&gt;\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;slot&gt;&lt;/slot&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    export default {\n\n    }\n&lt;/script&gt;</code></pre>\n<p><strong>Styiling of content passd to the slot is done inside the child.</strong> </p>\n<p>Rendering and dynamic content is related to the parent.</p>\n<h4 id="multiple-slots">Multiple Slots</h4>\n<p>If you want to render the content multiple times then just place as many <code>&lt;slot&gt;</code> as you want.</p>\n<p>But we can also name slots:</p>\n<pre><code class="language-html">&lt;!-- parent --&gt;\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;Quote&gt;\n            &lt;!-- this is going inside the slot component in the child --&gt;\n            &lt;h1 slot=&quot;title&quot;&gt;Quote Title&lt;/h1&gt;\n            &lt;p slot=&quot;content&quot;&gt;The quote&lt;/p&gt;\n        &lt;/Quote&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    import Quote from &#39;./components/Quote.vue&#39;;\n\n    export default {\n        components: {\n            Quote\n        }\n    }\n&lt;/script&gt;</code></pre>\n<pre><code class="language-html">&lt;!-- child --&gt;\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;slot name=&quot;title&quot;&gt;&lt;/slot&gt;\n    &lt;/div&gt;\n\n    &lt;div&gt;\n        &lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    export default {\n\n    }\n&lt;/script&gt;</code></pre>\n<p>If you name 3/4 slots the 4th one is going to be called the &quot;default&quot; one.</p>\n<h4 id="dynamic-components">Dynamic Components</h4>\n<p>The <code>&lt;component&gt;</code> element allows us to dynamically add components</p>\n<pre><code class="language-html">&lt;!-- parent --&gt;\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;button @click=&quot;selectedComponent = &#39;C1&#39;&quot;&gt;C1&lt;/button&gt;\n        &lt;button @click=&quot;selectedComponent = &#39;C2&#39;&quot;&gt;C2&lt;/button&gt;\n        &lt;button @click=&quot;selectedComponent = &#39;C3&#39;&quot;&gt;C3&lt;/button&gt;\n    &lt;/div&gt;\n\n    &lt;component v-bind:is=&quot;selectedComponent&quot;&gt;&lt;/component&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    import C1 from &#39;./components/C1.vue&#39;;\n    import C2 from &#39;./components/C2.vue&#39;;\n    import C3 from &#39;./components/C3.vue&#39;;\n\n    export default {\n        components: {\n            C1,\n            C2,\n            C3\n        }\n\n        data() {\n            return {\n                selectedComponent = &#39;C1&#39;\n            }\n        }\n\n    }\n&lt;/script&gt;</code></pre>\n<p>Dynamic Components get destroyed and re-created every time, but we can over write this behaviour with the <code>&lt;keep-alive&gt;</code> tag around the dynamic <code>&lt;component&gt;</code> element.</p>\n<p>We can control this flow with life cycle methods such as <code>activated</code> and <code>deactivated</code>.</p>\n<h3 id="custom-directives">Custom Directives</h3>\n<p>Directives have hooks:</p>\n<ul>\n<li><p>bind (once the directive is attached)</p>\n</li>\n<li><p>inserted (inserted in the parent node)</p>\n</li>\n<li><p>update (once component is updated w/o children)</p>\n</li>\n<li><p>componentUpdated (once component is updated w/ children)</p>\n</li>\n<li><p>unbind (when directive is removed)</p>\n</li>\n</ul>\n<p>Registering them globally in the <code>main.js</code> file.</p>\n<pre><code class="language-javascript">Vue.directive(&#39;directive-name&#39;, {\n    bind(el, binding, vnode) {\n        el.style.backgroundColor = &#39;green&#39;;\n    }\n});</code></pre>\n<pre><code class="language-html">&lt;p v-directive-name&gt;\n    Hello\n&lt;/p&gt;</code></pre>\n<h4 id="passing-values-to-custom-directives">Passing values to custom directives</h4>\n<pre><code class="language-javascript">Vue.directive(&#39;directive-name&#39;, {\n    bind(el, binding, vnode) {\n        el.style.backgroundColor = binding.value;\n    }\n});</code></pre>\n<pre><code class="language-html">&lt;p v-directive-name=&quot;&#39;red&#39;&quot;&gt;\n    Hello\n&lt;/p&gt;</code></pre>\n<h4 id="arguments">Arguments</h4>\n<pre><code class="language-javascript">Vue.directive(&#39;directive-name&#39;, {\n    bind(el, binding, vnode) {\n        if (binding.arg == &#39;background&#39;) {\n            el.style.backgroundColor = binding.value;\n        } else {\n            el.style.color = binding.value;\n        }\n\n    }\n});</code></pre>\n<pre><code class="language-html">&lt;p v-directive-name:background=&quot;&#39;red&#39;&quot;&gt;\n    Hello\n&lt;/p&gt;</code></pre>\n<h4 id="modifiers">Modifiers</h4>\n<pre><code class="language-javascript">Vue.directive(&#39;directive-name&#39;, {\n    bind(el, binding, vnode) {\n        let delay = 0;\n        if (binding.modifiers[&#39;delayed&#39;]) {\n            delay = 3000;\n        }\n\n        setTimeout(() =&gt; {\n            if (binding.arg == &#39;background&#39;) {\n                el.style.backgroundColor = binding.value;\n            } else {\n                el.style.color = binding.value;\n            }\n        }, delay);\n    }\n});</code></pre>\n<pre><code class="language-html">&lt;p v-directive-name:background.delayed=&quot;&#39;red&#39;&quot;&gt;\n    Hello\n&lt;/p&gt;</code></pre>\n<h4 id="registering-directives-locally">Registering Directives locally</h4>\n<p>we can use the <code>directives</code> properties inside the <code>&lt;script&gt;</code> tag.</p>\n<pre><code class="language-html">&lt;script&gt;\n    export default {\n        directives: {\n            &#39;directive-name&#39;: {\n                bind(el, binding, vnode) {\n                    let delay = 0;\n                    if (binding.modifiers[&#39;delayed&#39;]) {\n                        delay = 3000;\n                    }\n\n                    setTimeout(() =&gt; {\n                        if (binding.arg == &#39;background&#39;) {\n                            el.style.backgroundColor = binding.value;\n                        } else {\n                            el.style.color = binding.value;\n                        }\n                    }, delay);\n                }\n            }\n        }\n    }\n&lt;/script&gt;</code></pre>\n<h3 id="filters">Filters</h3>\n<p>A filter is a syntax feature you can use to transform some output in the <strong>template</strong>, it basically filters some <strong>data</strong>. For example, a filter that does <code>toUppercase()</code>. This will happen in the template only, not in the <code>data()</code>.</p>\n<pre><code class="language-javascript">// globally\nimport Vue from &#39;vue&#39;;\n\nVue.filter(&#39;filter-name&#39;, (value) =&gt; {\n    return value.toLowerCase();\n});</code></pre>\n<pre><code class="language-javascript">// locally\n\nexport default {\n    filters: {\n        toUppercase(value) {\n            return value.toUpperCase();\n        }\n    }\n}</code></pre>\n<p><strong>FIlters requires at leats one parameter.</strong></p>\n<p>And we use them like this.</p>\n<pre><code class="language-html">&lt;p&gt;\n    {{ text | toUppercase }}\n&lt;/p&gt;\n\n&lt;script&gt;\nexport default {\n    data() {\n        return {\n            text: &#39;Hello&#39;\n        };\n    },\n    filters: {\n        toUppercase(value) {\n            return value.toUpperCase();\n        }\n    }\n}\n&lt;/script&gt;</code></pre>\n<p>We can chain them by doing:</p>\n<p> <code>{{ data | filtername | anotherfilter | anotherone }}</code></p>\n<p>Sometimes, computed properties are a better solution than filters.</p>\n<h3 id="mixins">Mixins</h3>\n<p>Mixins are useful to avoid duplicate code, often involving computed properties and filters.</p>\n<p>We basically move the code we need to an external file where we export an object with those methods inside. Then we use the <code>mixins</code> property in out Vue instance:</p>\n<pre><code class="language-javascript">// mixin\nconst example = {\n      data() {\n        return {\n            text: &#39;Hello&#39;\n        }\n    },\n    methods: {\n        printText() {\n            console.log(this.text);\n        }\n    }\n};\nexport default example;</code></pre>\n<pre><code class="language-javascript">import example from &#39;./exampleMixin.js&#39;;\n\nexport default {\n    mixins: [example]\n}</code></pre>\n<p>IMPORTANT</p>\n<p><strong>A mixin gets merged with the already existing properties in the instance</strong>. </p>\n<p>Components always act last and mixins can&#39;t destroy components stuff.</p>\n<p>The mixin object is not really shared between components, every component gets his copy of the mixin.</p>\n<h1 id="animations">Animations</h1>\n<p>We can use animations and transitions when creating, modifying and deleting components.</p>\n<h3 id="transition">Transition</h3>\n<p>We can use the <code>transition</code> component to animate a <strong>single</strong> element.</p>\n<pre><code class="language-html">&lt;transition&gt;\n    &lt;p&gt;\n        Hey!\n    &lt;/p&gt;\n&lt;/transition&gt;</code></pre>\n<p>We usually attach CSS classes to do animations and Vue does this for us.</p>\n<p>We animate in an element with <code>*-enter</code>  where <code>*</code> is the name of the animation displayed in the initial state. After this <code>*-enter-active</code> gets attached. </p>\n<p>For leaving Vue attaches <code>*-leave</code> and then <code>*-leave-active</code>.</p>\n<p>The default name is <code>v-enter</code>.</p>\n<h4 id="assigning-css-classes-for-transitions">Assigning CSS classes for Transitions</h4>\n<p>Example:</p>\n<pre><code class="language-html">&lt;transition name=&quot;fade&quot;&gt;\n    &lt;p&gt;\n        Hey!\n    &lt;/p&gt;\n&lt;/transition&gt;\n\n&lt;style&gt;\n    /* one frame at the beginning and then gets removed */\n    .fade-enter {\n        opacity: 0;\n    }\n\n    /* here we set up the transition */\n    .fade-enter-active {\n        transition: opacity 1s;\n    }\n    .fade-leave {\n\n    }\n    .fade-leave-active {\n        trabistion: opacity 1s;\n        opacity: 0;\n    }\n&lt;/style&gt;</code></pre>\n<h3 id="animation">Animation</h3>\n<pre><code class="language-html">&lt;transition name=&quot;slide&quot;&gt;\n    &lt;p&gt;\n        Hey!\n    &lt;/p&gt;\n&lt;/transition&gt;\n\n&lt;style&gt;\n    .slide-enter {\n\n    }\n\n    .slide-enter-active {\n        animation: slide_in 1s ease-out forwards;\n    }\n    .slide-leave {\n\n    }\n    .slide-leave-active {\n        animaiton: slide_out 1s ease-out forwards;\n    }\n    @keyframes slide-in {\n        from {\n            transform: translateY(20px);\n        }\n        to {\n            transation: translationY(0);\n        }\n    }\n\n    @keyframes slide-out {\n        from {\n            transform: translateY(0);\n        }\n        to {\n            transation: translationY(20px);\n        }\n    }\n&lt;/style&gt;</code></pre>\n<p>If you want to mix animation and transitions make sure to indicate which one determines the lenght of the effect with the <code>type=&#39;&#39;</code> keyword.</p>\n<h4 id="onload-animation">Onload animation</h4>\n<p>We can use the initial attachment to the DOM with the <code>appear</code> attribute on the <code>transition</code> element.</p>\n<h3 id="custom-css-classes-names">Custom CSS Classes Names</h3>\n<p>If we don&#39;t want to use the default <code>v-enter</code>, <code>v-leave</code> etc. We can assign custom names to them:</p>\n<pre><code class="language-html">&lt;transition \n            enter-class=&quot;custom-name&quot; \n            enter-active-class=&quot;custom-name&quot;\n            leave-class=&quot;custom-name&quot;\n            leave-active-class=&quot;custom-name&quot;\n&gt;&lt;/transition&gt;</code></pre>\n<h3 id="transitioning-between-multiple-elements">Transitioning between Multiple Elements</h3>\n<p>If we want to transition between elements instead of animating a single one and then removing it we should add the <code>key</code> attribute to the elements., often we also need to use <code>mode=&quot;out-in&quot;</code>. </p>\n<h3 id="transition-js-hooks">Transition JS Hooks</h3>\n<p>The <code>transition</code> element emits some events in a specific moment. The flow is:</p>\n<p><code>before-enter, enter, after-enter, after-enter-cancelled, before-leave, leave, after-leave and after-leave-cancelled</code>.</p>\n<p>We can obviously listen to those events like: <code>@before-enter=&quot;someMethod&quot;</code>. So we can basiccaly execute code during those events. <strong>The methods receive the element where we listen as a parameter</strong>. We also need to tell Vue when to stop executing our animations inside the <code>enter</code> and <code>leave</code> hooks with the <code>done()</code> call inside them which is also a parameter.</p>\n<p>If we don&#39;t want to use CSS at all we can explicitly tell Vue with <code>:css=&quot;false&quot;</code>.</p>\n<h3 id="multiple-elements-animations">Multiple Elements Animations</h3>\n<p>To animate multiple items we have <code>&lt;transition-group&gt;</code> and we always need to key the elements</p>\n<pre><code class="language-html">&lt;transition-group&gt;\n    &lt;ul&gt;\n        &lt;li v-for=&quot;(element, index) in numbers&quot; :key=&quot;element&quot;&gt;\n        &lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/transition-group&gt;\n</code></pre>\n<p><code>&lt;transition-group&gt;</code> gives us a new CSS class: <code>*-move</code> used to move elements.</p>\n<h1 id="vue-router">Vue Router</h1>\n<p>If we use <code>history</code> mode every action is sent to the server, on the other hand the <code>hash</code> mode handles everything client-side in the application itself but we will get the <code>#</code> in the URL.</p>\n<h3 id="route-parameters">Route Parameters</h3>\n<p>If we need to pass dynamic data to the route we can use: <code>/somePath/:parameterName</code>.</p>\n<p>If we want to retreive the dynamic parameter we have to use: <code>this.$route.params.parameterName</code>. This doesn&#39;t get updated if we have multiple routes with multiple parameters in the same component. We can bypass this by using the <code>watch</code> property.</p>\n<pre><code class="language-javascript">data() {\n  return {\n    parameterName: this.$route.params.parameterName  \n  };  \n},\nwatch: {\n    &#39;$route&#39;: (to, from) {\n        this.parameterName = to.params.id;\n    }\n}</code></pre>\n<h4 id="query-parameters">Query parameters</h4>\n<p>We can obviously use the <code>?</code> query parameter  and retreive it with  <code>$route.query.queryName</code>.</p>\n<h3 id="nested-routes">Nested Routes</h3>\n<p>To have nested routes we add the <code>children: []</code> property to the route object.</p>\n<pre><code class="language-javascript">{ path: &#39;/user&#39;, component: User, children: [\n    { path: &#39;:id&#39;, component: UserID}\n]}</code></pre>\n<p>And we need to add the <code>&lt;router-view&gt;</code> inside the &#39;root&#39; route, in this case the <code>/user</code> route.</p>\n<h3 id="scroll-behavior">Scroll behavior</h3>\n<p>We can modify the scroll behaviour with this method:</p>\n<pre><code class="language-javascript">// to: is the route we want to navigate to\nscrollBehavior(to, from, savedPosition) {\n    return {x: 0, y: 700};\n}</code></pre>\n<p><code>savedPosition</code> is the position on the page where the user was before switching route.</p>\n<h3 id="navigation-guards">Navigation Guards</h3>\n<p>Middlewares that we can run before or after entering a route. This is useful especially for protected toutes.</p>\n<p>Inside <code>index.js</code> in the <code>router</code> folder we use <code>router.beforeEach()</code> to run code before entering a route:</p>\n<pre><code class="language-javascript">router.beforeEach((to, from, next) =&gt; {\n  if (to.meta.requiresAuth) {\n    // need to login\n  } else {\n    next();\n  }\n});</code></pre>\n<p>Where meta is a property on a specific route:</p>\n<pre><code class="language-javascript">  {\n    path: &#39;/profile&#39;,\n    name: &#39;Profile&#39;,\n    component: () =&gt; import(&#39;../views/Profile.vue&#39;),\n    meta: {\n      requiresAuth: true\n    }\n  }</code></pre>\n<p>Example:</p>\n<pre><code class="language-javascript">router.beforeEach((to, from, next) =&gt; {\n  if (to.meta.requiresAuth) {\n    UserService.isLoggedIn().then(result =&gt; {\n      if (result.user) {\n        next();\n      } else {\n        next({\n          name: &#39;Login&#39;\n        });\n      }\n    }).catch(err =&gt; {\n      console.error(err);\n    });\n  } else {\n    next();\n  }\n});</code></pre>\n<h3 id="lazy-loading">Lazy Loading</h3>\n<p>Lazy loading means we load only what we need.</p>\n<p>With webpack we can control the loading of the routes.</p>\n<pre><code class="language-javascript">const User = resolve =&gt; {\n    require.ensure([&#39;./components/User.vue&#39;], () =&gt; {\n        resolve(require(&#39;/components/User.vue&#39;));\n    });\n}</code></pre>\n<p>Whenever we want to load the User component we execute this function, which will load the User component only when we need it.</p>\n<h1 id="vuex---better-state-management">Vuex - Better State Management</h1>\n<p>In big applications, an Event Bus may get really crowded and changes are hard to track.</p>\n<p>That&#39;s why we may want <strong>Vuex</strong>. </p>\n<p>Vuex uses a central <strong>Store</strong> thats holds the application state. This store is available to the components, which can access it and modify it. In the central state we place all the shared data.</p>\n<p>The <strong>Store</strong> is a JavaScript file called <strong>store.js</strong>.</p>\n<h3 id="install">Install</h3>\n<p><code>npm install vuex --save</code></p>\n<h3 id="store">Store</h3>\n<p>Example of a store.js</p>\n<pre><code class="language-javascript">import Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;;\n\nVue.use(Vuex);\n\nconst Store = new Vuex.Store({\n       state: { // properties our app has\n        counter: 0\n    } \n});\n\nexport default Store;</code></pre>\n<p>And then we register it as a property inside the root Vue instance.</p>\n<p>Once it is registered we can access it everywhere with: <code>this.$store.state.counter</code>.</p>\n<h3 id="getters">Getters</h3>\n<p>To avoid duplicated code we can use <code>getters</code> to fetch the store from different places.</p>\n<pre><code class="language-javascript">const Store = new Vuex.Store({\n    state: { // properties our app has\n        counter: 0\n    },\n    getters: {\n        doubleCounter(state) {\n            return state.counter * 2;\n        }\n    }\n});</code></pre>\n<p>And we can access it with <code>this.$store.getters.doubleCounter</code>.</p>\n<h4 id="mapping-getters-to-properties">Mapping Getters to Properties</h4>\n<pre><code class="language-javascript">import { mapGetters} from &#39;vuex&#39;;\n\nexport default {\n    computed: {\n        ...mapGetters([\n            &#39;doubleCounter&#39;,\n            &#39;anotherGetter&#39;\n        ]),\n        ourOwnComputedProperty() {\n            // code\n        }\n    }\n}</code></pre>\n<p>And we can use them like this: <code>{{ doubleCounter }}</code>.</p>\n<h3 id="mutations">Mutations</h3>\n<p>Mutate the store. Mutations are committed from a component. </p>\n<pre><code class="language-javascript">mutaions: {\n    increment: state =&gt; {\n        state.counter++;\n    }\n}</code></pre>\n<p>And we use it like this: <code>this.$store.commit(&#39;increment&#39;)</code> in a component. We can even use them like we did with <code>mapGetters</code>.</p>\n<pre><code class="language-javascript">import {mapMutations} from &#39;vuex&#39;;\nexport default {\n    methods: {\n        ...mapMutations([\n            &#39;increment&#39;\n        ])\n    }\n}</code></pre>\n<p>Mutations are <strong>SYNC</strong>, not <strong>ASYNC</strong>.</p>\n<p>If we want to use ASYNC code in mutations we have to use <code>actions</code>.</p>\n<h3 id="actions">Actions</h3>\n<p>Extra piece of async code in mutations. The mutation gets committed once the action is finished. (Actions are triggered with the <code>store.dispatch</code> method).</p>\n<pre><code class="language-javascript">actions: {\n    incrementAfterTimeout: ({ commit }, payload) =&gt; {\n        setTimeout(commit(&#39;increment&#39;), payload.duration);\n    }\n}</code></pre>\n<pre><code class="language-javascript">import {mapActions} from &#39;vuex&#39;;\nexport default {\n    methods: {\n        ...mapActions([\n            &#39;increment&#39;\n        ])\n    }\n}</code></pre>\n<p>And we have to use it like this <code>increment({duration: 1000})</code> by passing an object.</p>\n<p>Note that this example is related to the previous mutation example.</p>\n<h4 id="edge-with-v-model">Edge with v-model</h4>\n<p>Imagine we have an input field and we want to bind the value in real time to a computed property. We also have a getter in the store that returns it, a mutation that does something with that and an action that commits the mutation. In order to set the value in the store in real time we have to use a <code>setter</code> inside the computed property, which is something really rare.</p>\n<p><code>v-model=&quot;value&quot;</code></p>\n<pre><code class="language-javascript">computed: {\n    value: {\n        get() {\n          return this.$store.getters.value;  \n        },\n\n        set(event) {\n            this.$store.dispatch(&#39;actionName&#39;, event.target.value); // this is used to dispatch an action, before it wasn&#39;t necessary because we used mapActions\n        }\n    }\n}</code></pre>\n<h3 id="modularizing-the-store">Modularizing the Store</h3>\n<p>To organize everything we should organize methods in <code>modules</code>. For example we could create a <code>counter.js</code> module with mutations, getters and actions related to the <code>counter</code>.</p>\n<p>The module:</p>\n<pre><code class="language-javascript">const state = {\n    counter: 0\n};\n\nconst getters = {\n    doubleCounter(state) {\n        return state.counter * 2;\n    }\n};\n\nconst mutations = {\n    increment: state =&gt; {\n        state.counter++;\n    }\n};\n\nconst actions = {\n    incrementAfterTimeout: ({ commit }, payload) =&gt; {\n        setTimeout(commit(&#39;increment&#39;), payload.duration);\n    }\n};\n\nexport default {state, getters, mutations, actions};</code></pre>\n<p>And we have to import it as follow:</p>\n<pre><code class="language-javascript">import counter from &#39;./modules/counter.js&#39;;\n\nconst Store = new Vuex.Store({\n    modules: {\n        store\n    }\n});</code></pre>\n<p>We could also organize everything by technical role instead of dividing stuff in modules.</p>\n'}}]);
//# sourceMappingURL=chunk-2d0e5ee5.0bbfc7b8.js.map