{"version":3,"sources":["webpack:///./src/views/docs/test.md"],"names":["module","exports"],"mappings":"mGAAAA,EAAOC,QAAU","file":"js/chunk-2d0e5ee5.0bbfc7b8.js","sourcesContent":["module.exports = \"<h1 style=\\\"text-align:center;\\\">Vue.js</h1>\\n\\n<p style=\\\"text-align:center;\\\">A Javascript framework for building Single Page Apps (SPAs).</p>\\n\\n<h1 id=\\\"table-of-contents\\\">Table of Contents</h1>\\n<ul>\\n<li><a href=\\\"#vuejs\\\">Vue.js</a></li>\\n<li><a href=\\\"#basics\\\">Basics</a><ul>\\n<li><a href=\\\"#data-property\\\">Data Property</a></li>\\n<li><a href=\\\"#methods\\\">Methods</a></li>\\n<li><a href=\\\"#vue-instance-lifecycle\\\">Vue Instance Lifecycle</a></li>\\n<li><a href=\\\"#computed-property\\\">Computed Property</a></li>\\n<li><a href=\\\"#watch-property\\\">Watch Property</a></li>\\n<li><a href=\\\"#directives\\\">Directives</a><pre><code>* [Shortcuts](#shortcuts)</code></pre></li>\\n<li><a href=\\\"#dynamic-styles\\\">Dynamic Styles</a><ul>\\n<li><a href=\\\"#array-sytax\\\">Array Sytax</a></li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li><a href=\\\"#vue-cli--workflows\\\">Vue CLI &amp; Workflows</a><ul>\\n<li><a href=\\\"#development-workflow\\\">Development Workflow</a></li>\\n<li><a href=\\\"#components\\\">Components</a><ul>\\n<li><a href=\\\"#registering-components-locally\\\">Registering Components Locally</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#communicating-between-components\\\">Communicating between Components</a><ul>\\n<li><a href=\\\"#parent---child\\\">Parent -&gt; <strong>Child</strong></a></li>\\n<li><a href=\\\"#child---parent\\\">Child -&gt; Parent</a></li>\\n<li><a href=\\\"#child---child\\\">Child -&gt; Child</a><ul>\\n<li><a href=\\\"#method-1\\\">Method #1</a></li>\\n<li><a href=\\\"#method-2\\\">Method #2</a></li>\\n<li><a href=\\\"#method-3\\\">Method #3</a></li>\\n<li><a href=\\\"#event-bus\\\">Event Bus</a></li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li><a href=\\\"#advanced-components\\\">Advanced Components</a><ul>\\n<li><a href=\\\"#slots\\\">Slots</a><ul>\\n<li><a href=\\\"#multiple-slots\\\">Multiple Slots</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#dynamic-components\\\">Dynamic Components</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#custom-directives\\\">Custom Directives</a><ul>\\n<li><a href=\\\"#passing-values-to-custom-directives\\\">Passing values to custom directives</a><ul>\\n<li><a href=\\\"#arguments\\\">Arguments</a></li>\\n<li><a href=\\\"#modifiers\\\">Modifiers</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#registering-directives-locally\\\">Registering Directives locally</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#filters\\\">Filters</a></li>\\n<li><a href=\\\"#mixins\\\">Mixins</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#animations\\\">Animations</a><ul>\\n<li><a href=\\\"#transition\\\">Transition</a><ul>\\n<li><a href=\\\"#assigning-css-classes-for-transitions\\\">Assigning CSS classes for Transitions</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#animation\\\">Animation</a><pre><code>* [Onload animation](#onload-animation)</code></pre></li>\\n<li><a href=\\\"#custom-css-classes-names\\\">Custom CSS Classes Names</a></li>\\n<li><a href=\\\"#transitioning-between-multiple-elements\\\">Transitioning between Multiple Elements</a></li>\\n<li><a href=\\\"#transition-js-hooks\\\">Transition JS Hooks</a></li>\\n<li><a href=\\\"#multiple-elements-animations\\\">Multiple Elements Animations</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#vue-router\\\">Vue Router</a><ul>\\n<li><a href=\\\"#route-parameters\\\">Route Parameters</a><ul>\\n<li><a href=\\\"#query-parameters\\\">Query parameters</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#nested-routes\\\">Nested Routes</a></li>\\n<li><a href=\\\"#scroll-behavior\\\">Scroll behavior</a></li>\\n<li><a href=\\\"#navigation-guards\\\">Navigation Guards</a></li>\\n<li><a href=\\\"#lazy-loading\\\">Lazy Loading</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#vuex---better-state-management\\\">Vuex - Better State Management</a><ul>\\n<li><a href=\\\"#install\\\">Install</a></li>\\n<li><a href=\\\"#store\\\">Store</a></li>\\n<li><a href=\\\"#getters\\\">Getters</a><ul>\\n<li><a href=\\\"#mapping-getters-to-properties\\\">Mapping Getters to Properties</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#mutations\\\">Mutations</a></li>\\n<li><a href=\\\"#actions\\\">Actions</a><pre><code>* [Edge with v-model](#edge-with-v-model)</code></pre></li>\\n<li><a href=\\\"#modularizing-the-store\\\">Modularizing the Store</a></li>\\n</ul>\\n</li>\\n</ul>\\n<h1 id=\\\"basics\\\">Basics</h1>\\n<p>A simple Vue.js built in the browser looks like this.</p>\\n<pre><code class=\\\"language-html\\\">&lt;div id=&quot;app&quot;&gt;\\n  {{ message }}\\n&lt;/div&gt;\\n\\n&lt;script&gt;\\n    const app = new Vue({\\n        el: &#39;#app&#39;,\\n        data: {\\n            message: &#39;Hello Vue!&#39;\\n        }\\n    });\\n&lt;/script&gt;</code></pre>\\n<p>We bind the application to a root element, in this case a DIV. Every Vue application starts by creating a new <strong>Vue instance</strong> with the <code>Vue</code> function.</p>\\n<p>A Vue application consists of a <strong>root Vue instance</strong> created with <code>new Vue</code>, optionally organized into a tree of nested, reusable components. For  example, a todo app’s component tree might look like this:</p>\\n<pre><code>Root Instance\\n└─ TodoList\\n   ├─ TodoItem\\n   │  ├─ DeleteTodoButton\\n   │  └─ EditTodoButton\\n   └─ TodoListFooter\\n      ├─ ClearTodosButton\\n      └─ TodoListStatistics</code></pre><h3 id=\\\"data-property\\\">Data Property</h3>\\n<p>When a Vue instance is created, it adds all the properties found in its <code>data</code> object to Vue’s <strong>reactivity system</strong>. When the values of those properties change, the view will “react”, updating to match the new values.</p>\\n<p>We use the <code>{{ }}</code> syntax to display dynamic values taken from the <code>data</code> property (see <a href=\\\"#Basics\\\">Basics</a>). We can also put small JS syntax inside <code>{{ }}</code>.</p>\\n<pre><code class=\\\"language-javascript\\\">const vm = new Vue({\\n    el: &#39;#app&#39;,\\n\\n    data: {\\n        num = 100;\\n    }\\n});</code></pre>\\n<p>When this data changes, the view will re-render.</p>\\n<p><strong>The data property is not reactive.</strong></p>\\n<h3 id=\\\"methods\\\">Methods</h3>\\n<p>Methods can also be accessed in the view with the <code>{{ }}</code> syntax:</p>\\n<pre><code class=\\\"language-html\\\">&lt;div id=&quot;app&quot;&gt;\\n  {{ sayHello() }}\\n&lt;/div&gt;\\n\\n&lt;script&gt;\\n    const app = new Vue({\\n        el: &#39;#app&#39;,\\n        data: {\\n            message: &#39;Hello Vue!&#39;\\n        }\\n        methods: {\\n            sayHello() {\\n                return &#39;Hello!&#39;;\\n            }\\n        }\\n    });\\n&lt;/script&gt;</code></pre>\\n<p>The <code>{{ }}</code> syntax can&#39;t be used in every element attribute:</p>\\n<pre><code class=\\\"language-html\\\">&lt;!-- NO --&gt;\\n&lt;a href=&quot;{{ link }}&quot;&gt;Link&lt;/a&gt;</code></pre>\\n<p>We need to use <a href=\\\"#Directives\\\"><strong>Directives</strong></a>.</p>\\n<pre><code class=\\\"language-html\\\">&lt;a v-bind:href=&quot;link&quot;&gt;Link&lt;/a&gt;</code></pre>\\n<h3 id=\\\"vue-instance-lifecycle\\\">Vue Instance Lifecycle</h3>\\n<p><img src=\\\"https://vuejs.org/images/lifecycle.png\\\" alt=\\\"The Vue Instance Lifecycle\\\"></p>\\n<p>We have access to different methods for different periods in the lifecycle of an instance. For example we can use the <code>created()</code> method and run code once the Vue instance gets created.</p>\\n<p>See documentation for more methods.</p>\\n<h3 id=\\\"computed-property\\\">Computed Property</h3>\\n<p>With the computed property we can execute a function only if its relative data gets changed. The methods are called every time we dynamically refresh the page. For example let&#39;s assume we have some buttons that increase a counter:</p>\\n<pre><code class=\\\"language-html\\\">&lt;div id=&quot;app&quot;&gt;\\n    &lt;button v-on:click=&quot;counter++&quot;&gt;Increase&lt;/button&gt;\\n    &lt;button v-on:click=&quot;counter--&quot;&gt;Decrease&lt;/button&gt;\\n    &lt;button v-on:click=&quot;secodCounter++&quot;&gt;Increase second&lt;/button&gt;\\n\\n    &lt;p&gt;Counter: {{ counter }}&lt;/p&gt;\\n    &lt;p&gt;Result: {{ result() }} | {{ output }}&lt;/p&gt;\\n&lt;/div&gt;\\n\\n&lt;script&gt;\\n    new Vue({\\n        el: &#39;#app&#39;,\\n        data: {\\n            counter: 0,\\n            seconCounter: 0\\n        },\\n        computed: {\\n            output() {\\n                return this.counter &gt; 5 ? &#39;Greater than 5&#39; : &#39;Smaller than 5&#39;\\n            }\\n        },\\n        methods: {\\n            result() {\\n                return this.counter &gt; 5 ? &#39;Greater than 5&#39; : &#39;Smaller than 5&#39;\\n            }\\n        }\\n    });\\n&lt;/script&gt;</code></pre>\\n<p>The result function gets called every time because Vue doesn&#39;t know if it needs to run it or not. On the other hand the output function gets called only when the counter gets modified.</p>\\n<p>Computed is aware of the logic inside it. See how we use &#39;output&#39; as a property and we don&#39;t invoke the function.</p>\\n<p>Computed properties are by default getter-only, but you can also provide a setter when you need it:</p>\\n<h3 id=\\\"watch-property\\\">Watch Property</h3>\\n<p>An object where keys are expressions to watch and values are the  corresponding callbacks. The value can also be a string of a method  name, or an Object that contains additional options. </p>\\n<p>Vue does provide a more generic way to observe and react to data changes on a Vue instance: <strong>watch properties</strong>. When you have some data that needs to change based on some other data, it is tempting to overuse <code>watch</code> owever, it is often a better idea to use a computed property rather than an imperative <code>watch</code> callback</p>\\n<p>The watch property lets us react to changes. Computed properties are much more optimized and they are best practice but they need to run <strong>SYNC</strong>.</p>\\n<p>The watch property is <strong>ASYNC</strong>.</p>\\n<h3 id=\\\"directives\\\">Directives</h3>\\n<p>Directives are special Vue commands.</p>\\n<table>\\n<thead>\\n<tr>\\n<th align=\\\"center\\\">keyword</th>\\n<th align=\\\"center\\\">action</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td align=\\\"center\\\">v-bind</td>\\n<td align=\\\"center\\\">bind some data dynamically to something</td>\\n</tr>\\n<tr>\\n<td align=\\\"center\\\">v-if</td>\\n<td align=\\\"center\\\">if statement</td>\\n</tr>\\n<tr>\\n<td align=\\\"center\\\">v-else</td>\\n<td align=\\\"center\\\">else statement</td>\\n</tr>\\n<tr>\\n<td align=\\\"center\\\">v-for</td>\\n<td align=\\\"center\\\">for loop</td>\\n</tr>\\n<tr>\\n<td align=\\\"center\\\">v-once</td>\\n<td align=\\\"center\\\">freezes dynamic updating (hot reload)</td>\\n</tr>\\n<tr>\\n<td align=\\\"center\\\">v-html</td>\\n<td align=\\\"center\\\">outputs raw html data from a value ([!] XSS [!])</td>\\n</tr>\\n<tr>\\n<td align=\\\"center\\\">v-on</td>\\n<td align=\\\"center\\\">listens on an event (click...)</td>\\n</tr>\\n<tr>\\n<td align=\\\"center\\\">v-model</td>\\n<td align=\\\"center\\\">Create a two-way binding on a form input element or a component.</td>\\n</tr>\\n</tbody></table>\\n<h4 id=\\\"shortcuts\\\">Shortcuts</h4>\\n<p><code>v-on: --&gt; @</code></p>\\n<p><code>v-bind: --&gt; :</code></p>\\n<h3 id=\\\"dynamic-styles\\\">Dynamic Styles</h3>\\n<p>We can pass an object to <code>v-bind:class</code> to dynamically toggle classes:</p>\\n<pre><code class=\\\"language-html\\\">&lt;div v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt;</code></pre>\\n<p>The above syntax means the presence of the <code>active</code> class will be determined by the <a href=\\\"https://developer.mozilla.org/en-US/docs/Glossary/Truthy\\\">truthiness</a> of the data property <code>isActive</code>.</p>\\n<p>You can have multiple classes toggled by having more fields in the object. In addition, the <code>v-bind:class</code> directive can also co-exist with the plain <code>class</code> attribute. So given the following template:</p>\\n<pre><code class=\\\"language-html\\\">&lt;div\\n  class=&quot;static&quot;\\n  v-bind:class=&quot;{ active: isActive, &#39;text-danger&#39;: hasError }&quot;\\n&gt;&lt;/div&gt;</code></pre>\\n<p>And the following data:</p>\\n<pre><code class=\\\"language-javascript\\\">data: {\\n  isActive: true,\\n  hasError: false\\n}</code></pre>\\n<p>It will render:</p>\\n<pre><code class=\\\"language-html\\\">&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;</code></pre>\\n<p>The bound object doesn’t have to be inline:</p>\\n<pre><code class=\\\"language-html\\\">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</code></pre>\\n<pre><code class=\\\"language-javascript\\\">data: {\\n  classObject: {\\n    active: true,\\n    &#39;text-danger&#39;: false\\n  }\\n}</code></pre>\\n<p>This will render the same result. We can also bind to a <a href=\\\"https://vuejs.org/v2/guide/computed.html\\\">computed property</a> that returns an object. This is a common and powerful pattern:</p>\\n<pre><code class=\\\"language-html\\\">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</code></pre>\\n<pre><code class=\\\"language-javascript\\\">data: {\\n  isActive: true,\\n  error: null\\n},\\ncomputed: {\\n  classObject: function () {\\n    return {\\n      active: this.isActive &amp;&amp; !this.error,\\n      &#39;text-danger&#39;: this.error &amp;&amp; this.error.type === &#39;fatal&#39;\\n    }\\n  }\\n}</code></pre>\\n<h4 id=\\\"array-sytax\\\">Array Sytax</h4>\\n<p>We can pass an array to <code>v-bind:class</code> to apply a list of classes:</p>\\n<pre><code class=\\\"language-html\\\">&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;</code></pre>\\n<pre><code class=\\\"language-javascript\\\">data: {\\n  activeClass: &#39;active&#39;,\\n  errorClass: &#39;text-danger&#39;\\n}</code></pre>\\n<p>Which will render:</p>\\n<pre><code class=\\\"language-html\\\">&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;</code></pre>\\n<p>If you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:</p>\\n<pre><code class=\\\"language-html\\\">&lt;div v-bind:class=&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;/div&gt;</code></pre>\\n<p>This will always apply <code>errorClass</code>, but will only apply <code>activeClass</code> when <code>isActive</code> is truthy.</p>\\n<h1 id=\\\"vue-cli--workflows\\\">Vue CLI &amp; Workflows</h1>\\n<p>Workflows optimize our code in multiple ways. We need, though, a development server:</p>\\n<p>This server will pre-compile and then serve the Vue app to the client, this is good for clientside performance.</p>\\n<p>All of this is pre-built, we don&#39;t need to write our own static server. </p>\\n<h3 id=\\\"development-workflow\\\">Development Workflow</h3>\\n<p>We compile everything server so the app we ship is ready to be viewed. This means that we can use Single FIled Templates (.vue files).</p>\\n<h3 id=\\\"components\\\">Components</h3>\\n<p>Re-usable pieces of code that are used in the Vue instance. It&#39;s like splitting the app in different parts based on their role. Components extend the Vue instance. </p>\\n<p><strong>The data property in components must be a function</strong></p>\\n<pre><code class=\\\"language-javascript\\\">Vue.component(&#39;ComponentName&#39;, {\\n    data() {\\n        return {\\n            str: &#39;Hello from component&#39;\\n        };\\n    }\\n});\\n\\nnew Vue({\\n    el: &#39;#app&#39;,\\n    data: {\\n        str: &#39;Hello&#39;\\n    }\\n});</code></pre>\\n<pre><code class=\\\"language-html\\\">&lt;div id=&quot;app&quot;&gt;\\n    &lt;ComponentName /&gt;\\n    &lt;ComponentName /&gt;\\n    &lt;ComponentName /&gt;\\n&lt;/div&gt;\\n\\n&lt;!-- as you can see we can re-use components --&gt;</code></pre>\\n<p>We could also have a shared data object by defining it globally but it is better to have it locally inside every component.</p>\\n<h4 id=\\\"registering-components-locally\\\">Registering Components Locally</h4>\\n<pre><code class=\\\"language-javascript\\\">// global\\nVue.component(&#39;ComponentName&#39;, {\\n    data() {\\n        return {\\n            str: &#39;Hello from global component&#39;\\n        };\\n    }\\n});</code></pre>\\n<pre><code class=\\\"language-javascript\\\">// local\\nconst ComponentName = {\\n    data() {\\n        return {\\n            str: &#39;Hello from local&#39;\\n        }\\n    }\\n}\\n\\nconst vm = new Vue({\\n       components: {\\n        ComponentName\\n    } \\n});</code></pre>\\n<p>We can of course move components to a separated file and import it like a JS module.</p>\\n<pre><code class=\\\"language-html\\\">&lt;template&gt;\\n    &lt;p&gt;\\n        {{ str }}\\n    &lt;/p&gt;\\n    &lt;ComponentName /&gt;\\n&lt;/template&gt;\\n\\n&lt;script&gt;\\n    import ComponentName from &#39;./components/ComponentName.vue&#39;;\\n\\n    export default {\\n        components: {\\n            ComponentName\\n        },\\n\\n        data: {\\n            str: &#39;Hello&#39;\\n        }\\n    }\\n&lt;/script&gt;</code></pre>\\n<p>We can also organize components by feature instead of having a single <code>components</code> folder.</p>\\n<h3 id=\\\"communicating-between-components\\\">Communicating between Components</h3>\\n<h4 id=\\\"parent---child\\\">Parent -&gt; <strong>Child</strong></h4>\\n<p>How can we share data from parent to child?</p>\\n<p>For transferring data from the parent to the child we use <code>props</code>.</p>\\n<pre><code class=\\\"language-html\\\">&lt;!-- child --&gt;\\n&lt;template&gt;\\n    &lt;p&gt;\\n        {{ name }}\\n    &lt;/p&gt;\\n&lt;/template&gt;\\n\\n&lt;script&gt;\\n    export default {\\n        props: [&#39;name&#39;]\\n    }\\n&lt;/script&gt;</code></pre>\\n<pre><code class=\\\"language-html\\\">&lt;!-- parent --&gt;\\n&lt;template&gt;\\n    &lt;div&gt;\\n        &lt;ChildComponent v-bind:name=&quot;name&quot; /&gt;    &lt;!-- we need v-bind --&gt;\\n    &lt;/div&gt;\\n&lt;/template&gt;\\n\\n&lt;script&gt;\\n    export default {\\n        data() {\\n            return {\\n                name: &#39;Leonardo&#39;    \\n            }\\n        }\\n    }\\n&lt;/script&gt;</code></pre>\\n<p>We can also use the props inside methods using the keyword <code>this</code>, just like accessing the data property</p>\\n<p>Props can also be an object, it is useful if you want to do some validation.</p>\\n<pre><code class=\\\"language-javascript\\\">export default {\\n    props : {\\n         name: String,\\n        required: true\\n    }\\n}</code></pre>\\n<h4 id=\\\"child---parent\\\">Child -&gt; Parent</h4>\\n<p>How can we share data from a child to his parent?</p>\\n<p>Since passing data from parent to child means passing pointers we use the <code>$emit</code> method.</p>\\n<pre><code class=\\\"language-javascript\\\">export default {\\n    resetName() {\\n        this.name = &#39;Reverted back&#39;;\\n        this.$emit(&#39;eventName&#39;, this.name);\\n    }\\n}</code></pre>\\n<p>And then in the parent we listen to this event with the v-on directive.</p>\\n<p><code>v-on:eventName=&quot;name = $event&quot;</code> ($event refers to the data passed to the event).</p>\\n<h4 id=\\\"child---child\\\">Child -&gt; Child</h4>\\n<ul>\\n<li><h4 id=\\\"method-1\\\">Method #1</h4>\\n<p>​    Emetting event like we did [here](####Child -&gt; Parent).</p>\\n</li>\\n<li><h4 id=\\\"method-2\\\">Method #2</h4>\\n<p>​    Passing a callback as a prop</p>\\n</li>\\n<li><h4 id=\\\"method-3\\\">Method #3</h4>\\n<p>​    Using an Event Bus, which is a separeted Vue instance. We use <code>$emit</code> with this instance     and we listen from events coming from that Bus.</p>\\n</li>\\n</ul>\\n<h4 id=\\\"event-bus\\\">Event Bus</h4>\\n<pre><code class=\\\"language-javascript\\\">// main.js\\nimport Vue from &#39;vue&#39;\\nimport App from &#39;./App.vue&#39;\\n\\nexport const eventBus = new Vue({\\n    methods: {\\n        changeAge(age) {\\n            this.$emit(&#39;ageWasEdited&#39;, age);\\n        }\\n    }\\n});\\n\\nnew Vue({\\n  el: &#39;#app&#39;,\\n  render: h =&gt; h(App)\\n})</code></pre>\\n<pre><code class=\\\"language-html\\\">&lt;!-- child 1 --&gt;\\n&lt;template&gt;\\n    &lt;div class=&quot;component&quot;&gt;\\n        &lt;h3&gt;You may edit the User here&lt;/h3&gt;\\n        &lt;p&gt;Edit me!&lt;/p&gt;\\n        &lt;p&gt;User Age: {{ userAge }}&lt;/p&gt;\\n        &lt;button @click=&quot;editAge&quot;&gt;Edit Age&lt;/button&gt;\\n    &lt;/div&gt;\\n&lt;/template&gt;\\n\\n&lt;script&gt;\\n    import {eventBus} from &#39;../main&#39;;\\n\\n    export default {\\n        props: [&#39;userAge&#39;],\\n        methods: {\\n            editAge() {\\n                this.userAge = 30;\\n\\n                eventBus.changeAge(this.userAge);\\n            }\\n        }\\n    }\\n&lt;/script&gt;</code></pre>\\n<pre><code class=\\\"language-html\\\">&lt;!-- child 2 --&gt;\\n&lt;template&gt;\\n    &lt;div class=&quot;component&quot;&gt;\\n        &lt;h3&gt;You may view the User Details here&lt;/h3&gt;\\n        &lt;p&gt;Many Details&lt;/p&gt;\\n        &lt;p&gt;User Name: {{ switchName() }}&lt;/p&gt;\\n        &lt;p&gt;User Age: {{ userAge }}&lt;/p&gt;\\n        &lt;button @click=&quot;resetName&quot;&gt;Reset Name&lt;/button&gt;\\n        &lt;button @click=&quot;resetFn()&quot;&gt;Reset Name&lt;/button&gt;\\n    &lt;/div&gt;\\n&lt;/template&gt;\\n\\n&lt;script&gt;\\n    import { eventBus } from &#39;../main&#39;;\\n\\n    export default {\\n        props: {\\n            myName: {\\n                type: String\\n            },\\n            resetFn: Function,\\n            userAge: Number\\n        },\\n        methods: {\\n            switchName() {\\n                return this.myName.split(&quot;&quot;).reverse().join(&quot;&quot;);\\n            },\\n            resetName() {\\n                this.myName = &#39;Max&#39;;\\n                this.$emit(&#39;nameWasReset&#39;, this.myName);\\n            }\\n        },\\n        created() {\\n            eventBus.$on(&#39;ageWasEdited&#39;, (age) =&gt; {\\n                this.userAge = age;\\n            });\\n        }\\n    }\\n&lt;/script&gt;</code></pre>\\n<pre><code class=\\\"language-html\\\">&lt;!-- parent --&gt;\\n&lt;template&gt;\\n    &lt;div class=&quot;component&quot;&gt;\\n        &lt;h1&gt;The User Component&lt;/h1&gt;\\n        &lt;p&gt;I&#39;m an awesome User!&lt;/p&gt;\\n        &lt;button @click=&quot;changeName&quot;&gt;Change my Name&lt;/button&gt;\\n        &lt;p&gt;Name is {{ name }}&lt;/p&gt;\\n        &lt;p&gt;Age is {{ age }}&lt;/p&gt;\\n        &lt;hr&gt;\\n        &lt;div class=&quot;row&quot;&gt;\\n            &lt;div class=&quot;col-xs-12 col-sm-6&quot;&gt;\\n                &lt;app-user-detail\\n                        :myName=&quot;name&quot;\\n                        @nameWasReset=&quot;name = $event&quot;\\n                        :resetFn=&quot;resetName&quot;\\n                        :userAge=&quot;age&quot;&gt;&lt;/app-user-detail&gt;\\n            &lt;/div&gt;\\n            &lt;div class=&quot;col-xs-12 col-sm-6&quot;&gt;\\n                &lt;app-user-edit\\n                        :userAge=&quot;age&quot;\\n                        @ageWasEdited=&quot;age = $event&quot;\\n                &gt;&lt;/app-user-edit&gt;\\n            &lt;/div&gt;\\n        &lt;/div&gt;\\n    &lt;/div&gt;\\n&lt;/template&gt;\\n\\n&lt;script&gt;\\n    import UserDetail from &#39;./UserDetail.vue&#39;;\\n    import UserEdit from &#39;./UserEdit.vue&#39;;\\n\\n    export default {\\n        data: function () {\\n            return {\\n                name: &#39;Max&#39;,\\n                age: 27\\n            };\\n        },\\n        methods: {\\n            changeName() {\\n                this.name = &#39;Anna&#39;;\\n            },\\n            resetName() {\\n                this.name = &#39;Max&#39;;\\n            }\\n        },\\n        components: {\\n            appUserDetail: UserDetail,\\n            appUserEdit: UserEdit\\n        }\\n    }\\n&lt;/script&gt;</code></pre>\\n<pre><code class=\\\"language-html\\\">&lt;!-- App.vue --&gt;\\n&lt;template&gt;\\n    &lt;div class=&quot;container&quot;&gt;\\n        &lt;div class=&quot;row&quot;&gt;\\n            &lt;div class=&quot;col-xs-12&quot;&gt;\\n                &lt;app-user&gt;&lt;/app-user&gt;\\n            &lt;/div&gt;\\n        &lt;/div&gt;\\n    &lt;/div&gt;\\n&lt;/template&gt;\\n\\n&lt;script&gt;\\n    import User from &#39;./components/User.vue&#39;;\\n\\n    export default {\\n        components: {\\n            appUser: User\\n        }\\n    }\\n&lt;/script&gt;</code></pre>\\n<p>We could also use <strong>Vuex</strong> to simplify State Management.</p>\\n<h3 id=\\\"advanced-components\\\">Advanced Components</h3>\\n<h4 id=\\\"slots\\\">Slots</h4>\\n<p>With slots we can pass content (entire HTML blocks) between components </p>\\n<pre><code class=\\\"language-html\\\">&lt;!-- parent --&gt;\\n&lt;template&gt;\\n    &lt;div&gt;\\n        &lt;Quote&gt;\\n            &lt;!-- this is going inside the slot component in the child --&gt;\\n            &lt;h1&gt;Quote Title&lt;/h1&gt;\\n            &lt;p&gt;The quote&lt;/p&gt;\\n        &lt;/Quote&gt;\\n    &lt;/div&gt;\\n&lt;/template&gt;\\n\\n&lt;script&gt;\\n    import Quote from &#39;./components/Quote.vue&#39;;\\n\\n    export default {\\n        components: {\\n            Quote\\n        }\\n    }\\n&lt;/script&gt;</code></pre>\\n<pre><code class=\\\"language-html\\\">&lt;!-- child --&gt;\\n&lt;template&gt;\\n    &lt;div&gt;\\n        &lt;slot&gt;&lt;/slot&gt;\\n    &lt;/div&gt;\\n&lt;/template&gt;\\n\\n&lt;script&gt;\\n    export default {\\n\\n    }\\n&lt;/script&gt;</code></pre>\\n<p><strong>Styiling of content passd to the slot is done inside the child.</strong> </p>\\n<p>Rendering and dynamic content is related to the parent.</p>\\n<h4 id=\\\"multiple-slots\\\">Multiple Slots</h4>\\n<p>If you want to render the content multiple times then just place as many <code>&lt;slot&gt;</code> as you want.</p>\\n<p>But we can also name slots:</p>\\n<pre><code class=\\\"language-html\\\">&lt;!-- parent --&gt;\\n&lt;template&gt;\\n    &lt;div&gt;\\n        &lt;Quote&gt;\\n            &lt;!-- this is going inside the slot component in the child --&gt;\\n            &lt;h1 slot=&quot;title&quot;&gt;Quote Title&lt;/h1&gt;\\n            &lt;p slot=&quot;content&quot;&gt;The quote&lt;/p&gt;\\n        &lt;/Quote&gt;\\n    &lt;/div&gt;\\n&lt;/template&gt;\\n\\n&lt;script&gt;\\n    import Quote from &#39;./components/Quote.vue&#39;;\\n\\n    export default {\\n        components: {\\n            Quote\\n        }\\n    }\\n&lt;/script&gt;</code></pre>\\n<pre><code class=\\\"language-html\\\">&lt;!-- child --&gt;\\n&lt;template&gt;\\n    &lt;div&gt;\\n        &lt;slot name=&quot;title&quot;&gt;&lt;/slot&gt;\\n    &lt;/div&gt;\\n\\n    &lt;div&gt;\\n        &lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;\\n    &lt;/div&gt;\\n&lt;/template&gt;\\n\\n&lt;script&gt;\\n    export default {\\n\\n    }\\n&lt;/script&gt;</code></pre>\\n<p>If you name 3/4 slots the 4th one is going to be called the &quot;default&quot; one.</p>\\n<h4 id=\\\"dynamic-components\\\">Dynamic Components</h4>\\n<p>The <code>&lt;component&gt;</code> element allows us to dynamically add components</p>\\n<pre><code class=\\\"language-html\\\">&lt;!-- parent --&gt;\\n&lt;template&gt;\\n    &lt;div&gt;\\n        &lt;button @click=&quot;selectedComponent = &#39;C1&#39;&quot;&gt;C1&lt;/button&gt;\\n        &lt;button @click=&quot;selectedComponent = &#39;C2&#39;&quot;&gt;C2&lt;/button&gt;\\n        &lt;button @click=&quot;selectedComponent = &#39;C3&#39;&quot;&gt;C3&lt;/button&gt;\\n    &lt;/div&gt;\\n\\n    &lt;component v-bind:is=&quot;selectedComponent&quot;&gt;&lt;/component&gt;\\n&lt;/template&gt;\\n\\n&lt;script&gt;\\n    import C1 from &#39;./components/C1.vue&#39;;\\n    import C2 from &#39;./components/C2.vue&#39;;\\n    import C3 from &#39;./components/C3.vue&#39;;\\n\\n    export default {\\n        components: {\\n            C1,\\n            C2,\\n            C3\\n        }\\n\\n        data() {\\n            return {\\n                selectedComponent = &#39;C1&#39;\\n            }\\n        }\\n\\n    }\\n&lt;/script&gt;</code></pre>\\n<p>Dynamic Components get destroyed and re-created every time, but we can over write this behaviour with the <code>&lt;keep-alive&gt;</code> tag around the dynamic <code>&lt;component&gt;</code> element.</p>\\n<p>We can control this flow with life cycle methods such as <code>activated</code> and <code>deactivated</code>.</p>\\n<h3 id=\\\"custom-directives\\\">Custom Directives</h3>\\n<p>Directives have hooks:</p>\\n<ul>\\n<li><p>bind (once the directive is attached)</p>\\n</li>\\n<li><p>inserted (inserted in the parent node)</p>\\n</li>\\n<li><p>update (once component is updated w/o children)</p>\\n</li>\\n<li><p>componentUpdated (once component is updated w/ children)</p>\\n</li>\\n<li><p>unbind (when directive is removed)</p>\\n</li>\\n</ul>\\n<p>Registering them globally in the <code>main.js</code> file.</p>\\n<pre><code class=\\\"language-javascript\\\">Vue.directive(&#39;directive-name&#39;, {\\n    bind(el, binding, vnode) {\\n        el.style.backgroundColor = &#39;green&#39;;\\n    }\\n});</code></pre>\\n<pre><code class=\\\"language-html\\\">&lt;p v-directive-name&gt;\\n    Hello\\n&lt;/p&gt;</code></pre>\\n<h4 id=\\\"passing-values-to-custom-directives\\\">Passing values to custom directives</h4>\\n<pre><code class=\\\"language-javascript\\\">Vue.directive(&#39;directive-name&#39;, {\\n    bind(el, binding, vnode) {\\n        el.style.backgroundColor = binding.value;\\n    }\\n});</code></pre>\\n<pre><code class=\\\"language-html\\\">&lt;p v-directive-name=&quot;&#39;red&#39;&quot;&gt;\\n    Hello\\n&lt;/p&gt;</code></pre>\\n<h4 id=\\\"arguments\\\">Arguments</h4>\\n<pre><code class=\\\"language-javascript\\\">Vue.directive(&#39;directive-name&#39;, {\\n    bind(el, binding, vnode) {\\n        if (binding.arg == &#39;background&#39;) {\\n            el.style.backgroundColor = binding.value;\\n        } else {\\n            el.style.color = binding.value;\\n        }\\n\\n    }\\n});</code></pre>\\n<pre><code class=\\\"language-html\\\">&lt;p v-directive-name:background=&quot;&#39;red&#39;&quot;&gt;\\n    Hello\\n&lt;/p&gt;</code></pre>\\n<h4 id=\\\"modifiers\\\">Modifiers</h4>\\n<pre><code class=\\\"language-javascript\\\">Vue.directive(&#39;directive-name&#39;, {\\n    bind(el, binding, vnode) {\\n        let delay = 0;\\n        if (binding.modifiers[&#39;delayed&#39;]) {\\n            delay = 3000;\\n        }\\n\\n        setTimeout(() =&gt; {\\n            if (binding.arg == &#39;background&#39;) {\\n                el.style.backgroundColor = binding.value;\\n            } else {\\n                el.style.color = binding.value;\\n            }\\n        }, delay);\\n    }\\n});</code></pre>\\n<pre><code class=\\\"language-html\\\">&lt;p v-directive-name:background.delayed=&quot;&#39;red&#39;&quot;&gt;\\n    Hello\\n&lt;/p&gt;</code></pre>\\n<h4 id=\\\"registering-directives-locally\\\">Registering Directives locally</h4>\\n<p>we can use the <code>directives</code> properties inside the <code>&lt;script&gt;</code> tag.</p>\\n<pre><code class=\\\"language-html\\\">&lt;script&gt;\\n    export default {\\n        directives: {\\n            &#39;directive-name&#39;: {\\n                bind(el, binding, vnode) {\\n                    let delay = 0;\\n                    if (binding.modifiers[&#39;delayed&#39;]) {\\n                        delay = 3000;\\n                    }\\n\\n                    setTimeout(() =&gt; {\\n                        if (binding.arg == &#39;background&#39;) {\\n                            el.style.backgroundColor = binding.value;\\n                        } else {\\n                            el.style.color = binding.value;\\n                        }\\n                    }, delay);\\n                }\\n            }\\n        }\\n    }\\n&lt;/script&gt;</code></pre>\\n<h3 id=\\\"filters\\\">Filters</h3>\\n<p>A filter is a syntax feature you can use to transform some output in the <strong>template</strong>, it basically filters some <strong>data</strong>. For example, a filter that does <code>toUppercase()</code>. This will happen in the template only, not in the <code>data()</code>.</p>\\n<pre><code class=\\\"language-javascript\\\">// globally\\nimport Vue from &#39;vue&#39;;\\n\\nVue.filter(&#39;filter-name&#39;, (value) =&gt; {\\n    return value.toLowerCase();\\n});</code></pre>\\n<pre><code class=\\\"language-javascript\\\">// locally\\n\\nexport default {\\n    filters: {\\n        toUppercase(value) {\\n            return value.toUpperCase();\\n        }\\n    }\\n}</code></pre>\\n<p><strong>FIlters requires at leats one parameter.</strong></p>\\n<p>And we use them like this.</p>\\n<pre><code class=\\\"language-html\\\">&lt;p&gt;\\n    {{ text | toUppercase }}\\n&lt;/p&gt;\\n\\n&lt;script&gt;\\nexport default {\\n    data() {\\n        return {\\n            text: &#39;Hello&#39;\\n        };\\n    },\\n    filters: {\\n        toUppercase(value) {\\n            return value.toUpperCase();\\n        }\\n    }\\n}\\n&lt;/script&gt;</code></pre>\\n<p>We can chain them by doing:</p>\\n<p> <code>{{ data | filtername | anotherfilter | anotherone }}</code></p>\\n<p>Sometimes, computed properties are a better solution than filters.</p>\\n<h3 id=\\\"mixins\\\">Mixins</h3>\\n<p>Mixins are useful to avoid duplicate code, often involving computed properties and filters.</p>\\n<p>We basically move the code we need to an external file where we export an object with those methods inside. Then we use the <code>mixins</code> property in out Vue instance:</p>\\n<pre><code class=\\\"language-javascript\\\">// mixin\\nconst example = {\\n      data() {\\n        return {\\n            text: &#39;Hello&#39;\\n        }\\n    },\\n    methods: {\\n        printText() {\\n            console.log(this.text);\\n        }\\n    }\\n};\\nexport default example;</code></pre>\\n<pre><code class=\\\"language-javascript\\\">import example from &#39;./exampleMixin.js&#39;;\\n\\nexport default {\\n    mixins: [example]\\n}</code></pre>\\n<p>IMPORTANT</p>\\n<p><strong>A mixin gets merged with the already existing properties in the instance</strong>. </p>\\n<p>Components always act last and mixins can&#39;t destroy components stuff.</p>\\n<p>The mixin object is not really shared between components, every component gets his copy of the mixin.</p>\\n<h1 id=\\\"animations\\\">Animations</h1>\\n<p>We can use animations and transitions when creating, modifying and deleting components.</p>\\n<h3 id=\\\"transition\\\">Transition</h3>\\n<p>We can use the <code>transition</code> component to animate a <strong>single</strong> element.</p>\\n<pre><code class=\\\"language-html\\\">&lt;transition&gt;\\n    &lt;p&gt;\\n        Hey!\\n    &lt;/p&gt;\\n&lt;/transition&gt;</code></pre>\\n<p>We usually attach CSS classes to do animations and Vue does this for us.</p>\\n<p>We animate in an element with <code>*-enter</code>  where <code>*</code> is the name of the animation displayed in the initial state. After this <code>*-enter-active</code> gets attached. </p>\\n<p>For leaving Vue attaches <code>*-leave</code> and then <code>*-leave-active</code>.</p>\\n<p>The default name is <code>v-enter</code>.</p>\\n<h4 id=\\\"assigning-css-classes-for-transitions\\\">Assigning CSS classes for Transitions</h4>\\n<p>Example:</p>\\n<pre><code class=\\\"language-html\\\">&lt;transition name=&quot;fade&quot;&gt;\\n    &lt;p&gt;\\n        Hey!\\n    &lt;/p&gt;\\n&lt;/transition&gt;\\n\\n&lt;style&gt;\\n    /* one frame at the beginning and then gets removed */\\n    .fade-enter {\\n        opacity: 0;\\n    }\\n\\n    /* here we set up the transition */\\n    .fade-enter-active {\\n        transition: opacity 1s;\\n    }\\n    .fade-leave {\\n\\n    }\\n    .fade-leave-active {\\n        trabistion: opacity 1s;\\n        opacity: 0;\\n    }\\n&lt;/style&gt;</code></pre>\\n<h3 id=\\\"animation\\\">Animation</h3>\\n<pre><code class=\\\"language-html\\\">&lt;transition name=&quot;slide&quot;&gt;\\n    &lt;p&gt;\\n        Hey!\\n    &lt;/p&gt;\\n&lt;/transition&gt;\\n\\n&lt;style&gt;\\n    .slide-enter {\\n\\n    }\\n\\n    .slide-enter-active {\\n        animation: slide_in 1s ease-out forwards;\\n    }\\n    .slide-leave {\\n\\n    }\\n    .slide-leave-active {\\n        animaiton: slide_out 1s ease-out forwards;\\n    }\\n    @keyframes slide-in {\\n        from {\\n            transform: translateY(20px);\\n        }\\n        to {\\n            transation: translationY(0);\\n        }\\n    }\\n\\n    @keyframes slide-out {\\n        from {\\n            transform: translateY(0);\\n        }\\n        to {\\n            transation: translationY(20px);\\n        }\\n    }\\n&lt;/style&gt;</code></pre>\\n<p>If you want to mix animation and transitions make sure to indicate which one determines the lenght of the effect with the <code>type=&#39;&#39;</code> keyword.</p>\\n<h4 id=\\\"onload-animation\\\">Onload animation</h4>\\n<p>We can use the initial attachment to the DOM with the <code>appear</code> attribute on the <code>transition</code> element.</p>\\n<h3 id=\\\"custom-css-classes-names\\\">Custom CSS Classes Names</h3>\\n<p>If we don&#39;t want to use the default <code>v-enter</code>, <code>v-leave</code> etc. We can assign custom names to them:</p>\\n<pre><code class=\\\"language-html\\\">&lt;transition \\n            enter-class=&quot;custom-name&quot; \\n            enter-active-class=&quot;custom-name&quot;\\n            leave-class=&quot;custom-name&quot;\\n            leave-active-class=&quot;custom-name&quot;\\n&gt;&lt;/transition&gt;</code></pre>\\n<h3 id=\\\"transitioning-between-multiple-elements\\\">Transitioning between Multiple Elements</h3>\\n<p>If we want to transition between elements instead of animating a single one and then removing it we should add the <code>key</code> attribute to the elements., often we also need to use <code>mode=&quot;out-in&quot;</code>. </p>\\n<h3 id=\\\"transition-js-hooks\\\">Transition JS Hooks</h3>\\n<p>The <code>transition</code> element emits some events in a specific moment. The flow is:</p>\\n<p><code>before-enter, enter, after-enter, after-enter-cancelled, before-leave, leave, after-leave and after-leave-cancelled</code>.</p>\\n<p>We can obviously listen to those events like: <code>@before-enter=&quot;someMethod&quot;</code>. So we can basiccaly execute code during those events. <strong>The methods receive the element where we listen as a parameter</strong>. We also need to tell Vue when to stop executing our animations inside the <code>enter</code> and <code>leave</code> hooks with the <code>done()</code> call inside them which is also a parameter.</p>\\n<p>If we don&#39;t want to use CSS at all we can explicitly tell Vue with <code>:css=&quot;false&quot;</code>.</p>\\n<h3 id=\\\"multiple-elements-animations\\\">Multiple Elements Animations</h3>\\n<p>To animate multiple items we have <code>&lt;transition-group&gt;</code> and we always need to key the elements</p>\\n<pre><code class=\\\"language-html\\\">&lt;transition-group&gt;\\n    &lt;ul&gt;\\n        &lt;li v-for=&quot;(element, index) in numbers&quot; :key=&quot;element&quot;&gt;\\n        &lt;/li&gt;\\n    &lt;/ul&gt;\\n&lt;/transition-group&gt;\\n</code></pre>\\n<p><code>&lt;transition-group&gt;</code> gives us a new CSS class: <code>*-move</code> used to move elements.</p>\\n<h1 id=\\\"vue-router\\\">Vue Router</h1>\\n<p>If we use <code>history</code> mode every action is sent to the server, on the other hand the <code>hash</code> mode handles everything client-side in the application itself but we will get the <code>#</code> in the URL.</p>\\n<h3 id=\\\"route-parameters\\\">Route Parameters</h3>\\n<p>If we need to pass dynamic data to the route we can use: <code>/somePath/:parameterName</code>.</p>\\n<p>If we want to retreive the dynamic parameter we have to use: <code>this.$route.params.parameterName</code>. This doesn&#39;t get updated if we have multiple routes with multiple parameters in the same component. We can bypass this by using the <code>watch</code> property.</p>\\n<pre><code class=\\\"language-javascript\\\">data() {\\n  return {\\n    parameterName: this.$route.params.parameterName  \\n  };  \\n},\\nwatch: {\\n    &#39;$route&#39;: (to, from) {\\n        this.parameterName = to.params.id;\\n    }\\n}</code></pre>\\n<h4 id=\\\"query-parameters\\\">Query parameters</h4>\\n<p>We can obviously use the <code>?</code> query parameter  and retreive it with  <code>$route.query.queryName</code>.</p>\\n<h3 id=\\\"nested-routes\\\">Nested Routes</h3>\\n<p>To have nested routes we add the <code>children: []</code> property to the route object.</p>\\n<pre><code class=\\\"language-javascript\\\">{ path: &#39;/user&#39;, component: User, children: [\\n    { path: &#39;:id&#39;, component: UserID}\\n]}</code></pre>\\n<p>And we need to add the <code>&lt;router-view&gt;</code> inside the &#39;root&#39; route, in this case the <code>/user</code> route.</p>\\n<h3 id=\\\"scroll-behavior\\\">Scroll behavior</h3>\\n<p>We can modify the scroll behaviour with this method:</p>\\n<pre><code class=\\\"language-javascript\\\">// to: is the route we want to navigate to\\nscrollBehavior(to, from, savedPosition) {\\n    return {x: 0, y: 700};\\n}</code></pre>\\n<p><code>savedPosition</code> is the position on the page where the user was before switching route.</p>\\n<h3 id=\\\"navigation-guards\\\">Navigation Guards</h3>\\n<p>Middlewares that we can run before or after entering a route. This is useful especially for protected toutes.</p>\\n<p>Inside <code>index.js</code> in the <code>router</code> folder we use <code>router.beforeEach()</code> to run code before entering a route:</p>\\n<pre><code class=\\\"language-javascript\\\">router.beforeEach((to, from, next) =&gt; {\\n  if (to.meta.requiresAuth) {\\n    // need to login\\n  } else {\\n    next();\\n  }\\n});</code></pre>\\n<p>Where meta is a property on a specific route:</p>\\n<pre><code class=\\\"language-javascript\\\">  {\\n    path: &#39;/profile&#39;,\\n    name: &#39;Profile&#39;,\\n    component: () =&gt; import(&#39;../views/Profile.vue&#39;),\\n    meta: {\\n      requiresAuth: true\\n    }\\n  }</code></pre>\\n<p>Example:</p>\\n<pre><code class=\\\"language-javascript\\\">router.beforeEach((to, from, next) =&gt; {\\n  if (to.meta.requiresAuth) {\\n    UserService.isLoggedIn().then(result =&gt; {\\n      if (result.user) {\\n        next();\\n      } else {\\n        next({\\n          name: &#39;Login&#39;\\n        });\\n      }\\n    }).catch(err =&gt; {\\n      console.error(err);\\n    });\\n  } else {\\n    next();\\n  }\\n});</code></pre>\\n<h3 id=\\\"lazy-loading\\\">Lazy Loading</h3>\\n<p>Lazy loading means we load only what we need.</p>\\n<p>With webpack we can control the loading of the routes.</p>\\n<pre><code class=\\\"language-javascript\\\">const User = resolve =&gt; {\\n    require.ensure([&#39;./components/User.vue&#39;], () =&gt; {\\n        resolve(require(&#39;/components/User.vue&#39;));\\n    });\\n}</code></pre>\\n<p>Whenever we want to load the User component we execute this function, which will load the User component only when we need it.</p>\\n<h1 id=\\\"vuex---better-state-management\\\">Vuex - Better State Management</h1>\\n<p>In big applications, an Event Bus may get really crowded and changes are hard to track.</p>\\n<p>That&#39;s why we may want <strong>Vuex</strong>. </p>\\n<p>Vuex uses a central <strong>Store</strong> thats holds the application state. This store is available to the components, which can access it and modify it. In the central state we place all the shared data.</p>\\n<p>The <strong>Store</strong> is a JavaScript file called <strong>store.js</strong>.</p>\\n<h3 id=\\\"install\\\">Install</h3>\\n<p><code>npm install vuex --save</code></p>\\n<h3 id=\\\"store\\\">Store</h3>\\n<p>Example of a store.js</p>\\n<pre><code class=\\\"language-javascript\\\">import Vue from &#39;vue&#39;\\nimport Vuex from &#39;vuex&#39;;\\n\\nVue.use(Vuex);\\n\\nconst Store = new Vuex.Store({\\n       state: { // properties our app has\\n        counter: 0\\n    } \\n});\\n\\nexport default Store;</code></pre>\\n<p>And then we register it as a property inside the root Vue instance.</p>\\n<p>Once it is registered we can access it everywhere with: <code>this.$store.state.counter</code>.</p>\\n<h3 id=\\\"getters\\\">Getters</h3>\\n<p>To avoid duplicated code we can use <code>getters</code> to fetch the store from different places.</p>\\n<pre><code class=\\\"language-javascript\\\">const Store = new Vuex.Store({\\n    state: { // properties our app has\\n        counter: 0\\n    },\\n    getters: {\\n        doubleCounter(state) {\\n            return state.counter * 2;\\n        }\\n    }\\n});</code></pre>\\n<p>And we can access it with <code>this.$store.getters.doubleCounter</code>.</p>\\n<h4 id=\\\"mapping-getters-to-properties\\\">Mapping Getters to Properties</h4>\\n<pre><code class=\\\"language-javascript\\\">import { mapGetters} from &#39;vuex&#39;;\\n\\nexport default {\\n    computed: {\\n        ...mapGetters([\\n            &#39;doubleCounter&#39;,\\n            &#39;anotherGetter&#39;\\n        ]),\\n        ourOwnComputedProperty() {\\n            // code\\n        }\\n    }\\n}</code></pre>\\n<p>And we can use them like this: <code>{{ doubleCounter }}</code>.</p>\\n<h3 id=\\\"mutations\\\">Mutations</h3>\\n<p>Mutate the store. Mutations are committed from a component. </p>\\n<pre><code class=\\\"language-javascript\\\">mutaions: {\\n    increment: state =&gt; {\\n        state.counter++;\\n    }\\n}</code></pre>\\n<p>And we use it like this: <code>this.$store.commit(&#39;increment&#39;)</code> in a component. We can even use them like we did with <code>mapGetters</code>.</p>\\n<pre><code class=\\\"language-javascript\\\">import {mapMutations} from &#39;vuex&#39;;\\nexport default {\\n    methods: {\\n        ...mapMutations([\\n            &#39;increment&#39;\\n        ])\\n    }\\n}</code></pre>\\n<p>Mutations are <strong>SYNC</strong>, not <strong>ASYNC</strong>.</p>\\n<p>If we want to use ASYNC code in mutations we have to use <code>actions</code>.</p>\\n<h3 id=\\\"actions\\\">Actions</h3>\\n<p>Extra piece of async code in mutations. The mutation gets committed once the action is finished. (Actions are triggered with the <code>store.dispatch</code> method).</p>\\n<pre><code class=\\\"language-javascript\\\">actions: {\\n    incrementAfterTimeout: ({ commit }, payload) =&gt; {\\n        setTimeout(commit(&#39;increment&#39;), payload.duration);\\n    }\\n}</code></pre>\\n<pre><code class=\\\"language-javascript\\\">import {mapActions} from &#39;vuex&#39;;\\nexport default {\\n    methods: {\\n        ...mapActions([\\n            &#39;increment&#39;\\n        ])\\n    }\\n}</code></pre>\\n<p>And we have to use it like this <code>increment({duration: 1000})</code> by passing an object.</p>\\n<p>Note that this example is related to the previous mutation example.</p>\\n<h4 id=\\\"edge-with-v-model\\\">Edge with v-model</h4>\\n<p>Imagine we have an input field and we want to bind the value in real time to a computed property. We also have a getter in the store that returns it, a mutation that does something with that and an action that commits the mutation. In order to set the value in the store in real time we have to use a <code>setter</code> inside the computed property, which is something really rare.</p>\\n<p><code>v-model=&quot;value&quot;</code></p>\\n<pre><code class=\\\"language-javascript\\\">computed: {\\n    value: {\\n        get() {\\n          return this.$store.getters.value;  \\n        },\\n\\n        set(event) {\\n            this.$store.dispatch(&#39;actionName&#39;, event.target.value); // this is used to dispatch an action, before it wasn&#39;t necessary because we used mapActions\\n        }\\n    }\\n}</code></pre>\\n<h3 id=\\\"modularizing-the-store\\\">Modularizing the Store</h3>\\n<p>To organize everything we should organize methods in <code>modules</code>. For example we could create a <code>counter.js</code> module with mutations, getters and actions related to the <code>counter</code>.</p>\\n<p>The module:</p>\\n<pre><code class=\\\"language-javascript\\\">const state = {\\n    counter: 0\\n};\\n\\nconst getters = {\\n    doubleCounter(state) {\\n        return state.counter * 2;\\n    }\\n};\\n\\nconst mutations = {\\n    increment: state =&gt; {\\n        state.counter++;\\n    }\\n};\\n\\nconst actions = {\\n    incrementAfterTimeout: ({ commit }, payload) =&gt; {\\n        setTimeout(commit(&#39;increment&#39;), payload.duration);\\n    }\\n};\\n\\nexport default {state, getters, mutations, actions};</code></pre>\\n<p>And we have to import it as follow:</p>\\n<pre><code class=\\\"language-javascript\\\">import counter from &#39;./modules/counter.js&#39;;\\n\\nconst Store = new Vuex.Store({\\n    modules: {\\n        store\\n    }\\n});</code></pre>\\n<p>We could also organize everything by technical role instead of dividing stuff in modules.</p>\\n\";"],"sourceRoot":""}